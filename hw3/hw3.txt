Problem 2:
Assume the left is the bottom and the right is the top, such as [1,2,3], 1 is at the
bottom and 3 is at the top.
Part(a): stack1=[]; stack2=[];
1. after enqueue1: stack1=[1]; stack2=[];
2. after enqueue2: stack1=[1,2]; stack2=[];
3: dequeue: stack2 is empty so pop stack1 one by one. The order is from top to bottom. Then when push to stack2, 1, who is the last to be popped, should be on the top. So stack1=[]; stack2=[2,1]; Now pop from stack2 which is 1.
4. enqueue3: stack1=[3]; stack2=[2];
5. enqueue4: stack1=[3,4]; stack2=[2];
6. dequeue: stack2 is not empty, pop from it. So 2 gets popped and stack2=[]; stack1=[3,4];
7. enqueue5: stack1=[3,4,5]; stack2=[];
8. enqueue6: stack1=[3,4,5,6]; stack2=[];
/////////////
Part(b):
run time of enqueue: pushing one element to the end of a linked list or array takes O(1);
run time of dequeue: worst case, stack2 is always empty. So we need to pop everything from stack1, which takes O(n). Then, push them into stack2, which takes O(n) and pop the top, which takes O(1). So the run time is O(n).
/////////////
Part(c): We push n values on stack1 while stack2 is empty, which costs n run time by n times call of function. The first call of dequeue pops nth times and push nth times to stack2, taking 2n+1 time including the final pop from stack2. However, after the first all, we guarantee that the next n-1 call of dequeue only takes O(1). As a result, the runtime is (n+2n+1+(n-1)*1)/(n+n) = 2. So the amortized run time is O(2).
/////////////
Part(d):
run time of enqueue: pushing one element to the stack takes O(1). 
run time of dequeue: worst case, stack2 is always empty. Pop everything from stack1, which takes Sigma[x = 1 -> n]x = (n+1)n/2. Then push them into stack2, which takes n time and pop from the top, taking n. The total run time is (n+1)*n/2 + 2n;

Amortized run time: First push n values to stack1, costing n time with n times call of function. The first call of dequeue takes n^2 but we guarantee that the next n-1  calls of function take O(x) each while x is the left values in stack2. The total run time of next n-1 calls of dequeue is Sigma[x = n-1 -> 1] x = n(n-1)/2.
Total run time: n(n+1)/2 + n(n-1)/2 + 2n
Total times of calling function: 2n;
Amortized run time = total run time/ times = n/2 + 1 = O(n);
